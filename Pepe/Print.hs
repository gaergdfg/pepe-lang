-- File generated by the BNF Converter (bnfc 2.9.4).

{-# LANGUAGE CPP                  #-}
{-# LANGUAGE FlexibleInstances    #-}
{-# LANGUAGE LambdaCase           #-}
#if __GLASGOW_HASKELL__ <= 708
{-# LANGUAGE OverlappingInstances #-}
#endif

-- | Pretty-printer for Pepe.

module Pepe.Print where

import           Data.Char (Char, isSpace)
import qualified Pepe.Abs
import           Prelude   (Bool (..), Double, Int, Integer, ShowS, String, all,
                            elem, foldr, id, map, null, replicate, showChar,
                            showString, shows, span, ($), (*), (+), (++), (-),
                            (.), (<), (==))

-- | The top-level printing method.

printTree :: Print a => a -> String
printTree = render . prt 0

type Doc = [ShowS] -> [ShowS]

doc :: ShowS -> Doc
doc = (:)

render :: Doc -> String
render d = rend 0 False (map ($ "") $ d []) ""
  where
  rend
    :: Int        -- ^ Indentation level.
    -> Bool       -- ^ Pending indentation to be output before next character?
    -> [String]
    -> ShowS
  rend i p = \case
      "["      :ts -> char '[' . rend i False ts
      "("      :ts -> char '(' . rend i False ts
      "{"      :ts -> onNewLine i     p . showChar   '{'  . new (i+1) ts
      "}" : ";":ts -> onNewLine (i-1) p . showString "};" . new (i-1) ts
      "}"      :ts -> onNewLine (i-1) p . showChar   '}'  . new (i-1) ts
      [";"]        -> char ';'
      ";"      :ts -> char ';' . new i ts
      t  : ts@(s:_) | closingOrPunctuation s
                   -> pending . showString t . rend i False ts
      t        :ts -> pending . space t      . rend i False ts
      []           -> id
    where
    -- Output character after pending indentation.
    char :: Char -> ShowS
    char c = pending . showChar c

    -- Output pending indentation.
    pending :: ShowS
    pending = if p then indent i else id

  -- Indentation (spaces) for given indentation level.
  indent :: Int -> ShowS
  indent i = replicateS (2*i) (showChar ' ')

  -- Continue rendering in new line with new indentation.
  new :: Int -> [String] -> ShowS
  new j ts = showChar '\n' . rend j True ts

  -- Make sure we are on a fresh line.
  onNewLine :: Int -> Bool -> ShowS
  onNewLine i p = (if p then id else showChar '\n') . indent i

  -- Separate given string from following text by a space (if needed).
  space :: String -> ShowS
  space t s =
    case (all isSpace t', null spc, null rest) of
      (True , _   , True ) -> []              -- remove trailing space
      (False, _   , True ) -> t'              -- remove trailing space
      (False, True, False) -> t' ++ ' ' : s   -- add space if none
      _                    -> t' ++ s
    where
      t'          = showString t []
      (spc, rest) = span isSpace s

  closingOrPunctuation :: String -> Bool
  closingOrPunctuation [c] = c `elem` closerOrPunct
  closingOrPunctuation _   = False

  closerOrPunct :: String
  closerOrPunct = ")],;"

parenth :: Doc -> Doc
parenth ss = doc (showChar '(') . ss . doc (showChar ')')

concatS :: [ShowS] -> ShowS
concatS = foldr (.) id

concatD :: [Doc] -> Doc
concatD = foldr (.) id

replicateS :: Int -> ShowS -> ShowS
replicateS n f = concatS (replicate n f)

-- | The printer class does the job.

class Print a where
  prt :: Int -> a -> Doc

instance {-# OVERLAPPABLE #-} Print a => Print [a] where
  prt i = concatD . map (prt i)

instance Print Char where
  prt _ c = doc (showChar '\'' . mkEsc '\'' c . showChar '\'')

instance Print String where
  prt _ = printString

printString :: String -> Doc
printString s = doc (showChar '"' . concatS (map (mkEsc '"') s) . showChar '"')

mkEsc :: Char -> Char -> ShowS
mkEsc q = \case
  s | s == q -> showChar '\\' . showChar s
  '\\'       -> showString "\\\\"
  '\n'       -> showString "\\n"
  '\t'       -> showString "\\t"
  s          -> showChar s

prPrec :: Int -> Int -> Doc -> Doc
prPrec i j = if j < i then parenth else id

instance Print Integer where
  prt _ x = doc (shows x)

instance Print Double where
  prt _ x = doc (shows x)

instance Print Pepe.Abs.Ident where
  prt _ (Pepe.Abs.Ident i) = doc $ showString i
instance Print (Pepe.Abs.Program' a) where
  prt i = \case
    Pepe.Abs.PProgram _ topdefs -> prPrec i 0 (concatD [prt 0 topdefs])

instance Print (Pepe.Abs.TopDef' a) where
  prt i = \case
    Pepe.Abs.PFnDef _ type_ id_ args block -> prPrec i 0 (concatD [prt 0 type_, prt 0 id_, doc (showString "("), prt 0 args, doc (showString ")"), prt 0 block])
    Pepe.Abs.PVarInit _ type_ id_ expr -> prPrec i 0 (concatD [prt 0 type_, prt 0 id_, doc (showString "="), prt 0 expr, doc (showString ";")])
    Pepe.Abs.PVarDef _ type_ id_ -> prPrec i 0 (concatD [prt 0 type_, prt 0 id_, doc (showString ";")])

instance Print [Pepe.Abs.TopDef' a] where
  prt _ []     = concatD []
  prt _ [x]    = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print (Pepe.Abs.Arg' a) where
  prt i = \case
    Pepe.Abs.PArg _ type_ id_ -> prPrec i 0 (concatD [prt 0 type_, prt 0 id_])
    Pepe.Abs.PRefArg _ type_ id_ -> prPrec i 0 (concatD [doc (showString "ref"), prt 0 type_, prt 0 id_])

instance Print [Pepe.Abs.Arg' a] where
  prt _ []     = concatD []
  prt _ [x]    = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print (Pepe.Abs.Block' a) where
  prt i = \case
    Pepe.Abs.SBlock _ stmts -> prPrec i 0 (concatD [doc (showString "{"), prt 0 stmts, doc (showString "}")])

instance Print (Pepe.Abs.Stmt' a) where
  prt i = \case
    Pepe.Abs.SEmpty _ -> prPrec i 0 (concatD [doc (showString ";")])
    Pepe.Abs.SBStmt _ block -> prPrec i 0 (concatD [prt 0 block])
    Pepe.Abs.STopDef _ topdef -> prPrec i 0 (concatD [prt 0 topdef])
    Pepe.Abs.SAss _ id_ expr -> prPrec i 0 (concatD [prt 0 id_, doc (showString "="), prt 0 expr, doc (showString ";")])
    Pepe.Abs.SIncr _ id_ -> prPrec i 0 (concatD [prt 0 id_, doc (showString "++"), doc (showString ";")])
    Pepe.Abs.SDecr _ id_ -> prPrec i 0 (concatD [prt 0 id_, doc (showString "--"), doc (showString ";")])
    Pepe.Abs.SRet _ expr -> prPrec i 0 (concatD [doc (showString "return"), prt 0 expr, doc (showString ";")])
    Pepe.Abs.SRetVoid _ -> prPrec i 0 (concatD [doc (showString "return"), doc (showString ";")])
    Pepe.Abs.SCond _ expr block -> prPrec i 0 (concatD [doc (showString "if"), doc (showString "("), prt 0 expr, doc (showString ")"), prt 0 block])
    Pepe.Abs.SCondElse _ expr block1 block2 -> prPrec i 0 (concatD [doc (showString "if"), doc (showString "("), prt 0 expr, doc (showString ")"), prt 0 block1, doc (showString "else"), prt 0 block2])
    Pepe.Abs.SWhile _ expr block -> prPrec i 0 (concatD [doc (showString "while"), doc (showString "("), prt 0 expr, doc (showString ")"), prt 0 block])
    Pepe.Abs.SBreak _ -> prPrec i 0 (concatD [doc (showString "break"), doc (showString ";")])
    Pepe.Abs.SCont _ -> prPrec i 0 (concatD [doc (showString "continue"), doc (showString ";")])
    Pepe.Abs.SExp _ expr -> prPrec i 0 (concatD [prt 0 expr, doc (showString ";")])

instance Print [Pepe.Abs.Stmt' a] where
  prt _ []     = concatD []
  prt _ (x:xs) = concatD [prt 0 x, prt 0 xs]

instance Print (Pepe.Abs.Type' a) where
  prt i = \case
    Pepe.Abs.TInt _    -> prPrec i 0 (concatD [doc (showString "int")])
    Pepe.Abs.TString _ -> prPrec i 0 (concatD [doc (showString "string")])
    Pepe.Abs.TBool _   -> prPrec i 0 (concatD [doc (showString "bool")])
    Pepe.Abs.TVoid _   -> prPrec i 0 (concatD [doc (showString "void")])

instance Print [Pepe.Abs.Type' a] where
  prt _ []     = concatD []
  prt _ [x]    = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print (Pepe.Abs.Expr' a) where
  prt i = \case
    Pepe.Abs.EVar _ id_ -> prPrec i 6 (concatD [prt 0 id_])
    Pepe.Abs.ELitInt _ n -> prPrec i 6 (concatD [prt 0 n])
    Pepe.Abs.ELitTrue _ -> prPrec i 6 (concatD [doc (showString "true")])
    Pepe.Abs.ELitFalse _ -> prPrec i 6 (concatD [doc (showString "false")])
    Pepe.Abs.EApp _ id_ exprs -> prPrec i 6 (concatD [prt 0 id_, doc (showString "("), prt 0 exprs, doc (showString ")")])
    Pepe.Abs.EString _ str -> prPrec i 6 (concatD [printString str])
    Pepe.Abs.ENeg _ expr -> prPrec i 5 (concatD [doc (showString "-"), prt 6 expr])
    Pepe.Abs.ENot _ expr -> prPrec i 5 (concatD [doc (showString "!"), prt 6 expr])
    Pepe.Abs.EMul _ expr1 mulop expr2 -> prPrec i 4 (concatD [prt 4 expr1, prt 0 mulop, prt 5 expr2])
    Pepe.Abs.EAdd _ expr1 addop expr2 -> prPrec i 3 (concatD [prt 3 expr1, prt 0 addop, prt 4 expr2])
    Pepe.Abs.ERel _ expr1 relop expr2 -> prPrec i 2 (concatD [prt 2 expr1, prt 0 relop, prt 3 expr2])
    Pepe.Abs.EAnd _ expr1 expr2 -> prPrec i 1 (concatD [prt 2 expr1, doc (showString "&&"), prt 1 expr2])
    Pepe.Abs.EOr _ expr1 expr2 -> prPrec i 0 (concatD [prt 1 expr1, doc (showString "||"), prt 0 expr2])

instance Print [Pepe.Abs.Expr' a] where
  prt _ []     = concatD []
  prt _ [x]    = concatD [prt 0 x]
  prt _ (x:xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print (Pepe.Abs.AddOp' a) where
  prt i = \case
    Pepe.Abs.OPlus _  -> prPrec i 0 (concatD [doc (showString "+")])
    Pepe.Abs.OMinus _ -> prPrec i 0 (concatD [doc (showString "-")])

instance Print (Pepe.Abs.MulOp' a) where
  prt i = \case
    Pepe.Abs.OTimes _ -> prPrec i 0 (concatD [doc (showString "*")])
    Pepe.Abs.ODiv _   -> prPrec i 0 (concatD [doc (showString "/")])
    Pepe.Abs.OMod _   -> prPrec i 0 (concatD [doc (showString "%")])

instance Print (Pepe.Abs.RelOp' a) where
  prt i = \case
    Pepe.Abs.OLth _ -> prPrec i 0 (concatD [doc (showString "<")])
    Pepe.Abs.OLE _  -> prPrec i 0 (concatD [doc (showString "<=")])
    Pepe.Abs.OGth _ -> prPrec i 0 (concatD [doc (showString ">")])
    Pepe.Abs.OGE _  -> prPrec i 0 (concatD [doc (showString ">=")])
    Pepe.Abs.OEq _  -> prPrec i 0 (concatD [doc (showString "==")])
    Pepe.Abs.ONe _  -> prPrec i 0 (concatD [doc (showString "!=")])
